<?php

namespace MediaWiki\Extension\WikimediaMaintenance;

use MediaWiki\MediaWikiServices;
use Wikimedia\Rdbms\IDatabase;

require __DIR__ . '/WikimediaMaintenance.php';

/**
 * Script to fix ipblocks.ipb_by_actor values corrupted by cross-wiki suppression (T260485).
 */
class FixT260485 extends \Maintenance {
	private $messagePatterns;

	public function __construct() {
		parent::__construct();
		$this->addDescription( 'Fix ipb_by_actor values corrupted by cross-wiki suppression' );
		$this->addOption( 'messages',
			'JSON message file generated by messageHistory.php', true, true );
		$this->addOption( 'start',
			'The minimum timestamp', false, true );
		$this->addOption( 'end',
			'The maximum timestamp', false, true );
		$this->addOption( 'dry-run',
			'Do not actually change anything' );
	}

	/**
	 * @suppress PhanPossiblyUndeclaredVariable $row is always set after the numRows() check
	 */
	public function execute() {
		$this->loadMessages();

		$dbr = $this->getDB( DB_REPLICA );
		$cursorConds = [];
		$filter = [];
		if ( $this->hasOption( 'start' ) ) {
			$start = strtotime( $this->getOption( 'start' ) );
			if ( !$start ) {
				$this->fatalError( 'Invalid timestamp for --start' );
			}
			$cursorConds = [ 'ipb_timestamp >= ' . $dbr->addQuotes( $dbr->timestamp( $start ) ) ];
		}
		if ( $this->hasOption( 'end' ) ) {
			$end = strtotime( $this->getOption( 'end' ) );
			if ( !$end ) {
				$this->fatalError( 'Invalid timestamp for --end' );
			}
			$filter[] = 'ipb_timestamp <= ' . $dbr->addQuotes( $dbr->timestamp( $end ) );
		}

		$services = MediaWikiServices::getInstance();
		$commentStore = $services->getCommentStore();
		$commentJoin = $commentStore->getJoin( 'ipb_reason' );
		$commentJoin['join_conds'] = $commentJoin['joins'];

		$numChanged = 0;
		$numUnchanged = 0;
		$numFailed = 0;

		while ( true ) {
			$res = $dbr->newSelectQueryBuilder()
				->select( [ 'ipb_id', 'ipb_by_actor', 'ipb_timestamp' ] )
				->from( 'ipblocks' )
				->where( array_merge( $filter, $cursorConds ) )
				->queryInfo( $commentJoin )
				->orderBy( [ 'ipb_timestamp', 'ipb_id' ] )
				->limit( 100 )
				->caller( __METHOD__ )
				->fetchResultSet();

			if ( !$res->numRows() ) {
				break;
			}

			foreach ( $res as $row ) {
				// Get the admin name from ipb_reason_*
				$comment = $commentStore->getComment( 'ipb_reason', $row );
				$reasonAdmin = $this->matchSuppressReason( $comment->text );
				if ( $reasonAdmin === false ) {
					continue;
				}

				// Is it already correct?
				if ( $this->checkLocalActor( $row->ipb_by_actor, $reasonAdmin ) ) {
					$this->output( "Unchanged: {$row->ipb_id}\n" );
					$numUnchanged++;
					continue;
				}

				// Cross-check against the meta username
				if ( !$this->checkMetaActor( $row->ipb_by_actor, $reasonAdmin ) ) {
					echo "ERROR: actor name mismatch. " .
						"ID={$row->ipb_id}, actor={$row->ipb_by_actor}, admin=\"$reasonAdmin\"\n";
					$numFailed++;
					continue;
				}

				// Update the row
				$this->updateActor( $row->ipb_id, $reasonAdmin, $row->ipb_by_actor );
				$numChanged++;
			}

			$cursorConds = [
				'(ipb_timestamp = ' . $dbr->addQuotes( $row->ipb_timestamp ) .
				' AND ipb_id > ' . $dbr->addQuotes( $row->ipb_id ) . ') ' .
				'OR ipb_timestamp > ' . $dbr->addQuotes( $row->ipb_timestamp )
			];
		}
		echo "Done. Changed rows: $numChanged. Unchanged rows: $numUnchanged. Failed rows: $numFailed.\n";
	}

	private function loadMessages() {
		$this->messagePatterns = [];
		$json = file_get_contents( $this->getOption( 'messages' ) );
		if ( $json === false ) {
			$this->fatalError( "Unable to load messages file" );
		}
		$data = json_decode( $json, true );
		if ( $data === null ) {
			$this->fatalError( "Error decoding JSON from messages file" );
		}
		foreach ( $data as $lang => $messages ) {
			foreach ( $messages as $message ) {
				$value = $message['value'];
				if ( preg_match( '/(.*)\$1(.*)\$2(.*)/', $value, $m ) ) {
					$pattern = '/' .
						preg_quote( $m[1], '/' ) .
						'(.*)' .
						preg_quote( $m[2], '/' ) .
						'(.*)' .
						preg_quote( $m[3], '/' ) .
						'/';
					$this->messagePatterns[] = $pattern;
				}
			}
		}
	}

	/**
	 * Match the reason text against known values of centralauth-admin-suppressreason.
	 * If it matches one, return the admin name parameter.
	 *
	 * @param string $reason
	 * @return string|bool
	 */
	private function matchSuppressReason( $reason ) {
		foreach ( $this->messagePatterns as $regex ) {
			if ( preg_match( $regex, $reason, $m ) ) {
				return $m[1];
			}
		}
		return false;
	}

	/**
	 * Check whether the actor ID locally matches the name
	 *
	 * @param int $actor
	 * @param string $name
	 * @return bool
	 */
	private function checkLocalActor( $actor, $name ) {
		return $this->checkActorOnDB(
			$this->getDB( DB_REPLICA ),
			$actor,
			$name
		);
	}

	/**
	 * Check whether the actor ID matches the given name on metawiki
	 *
	 * @param int $actor
	 * @param string $name
	 * @return bool
	 */
	private function checkMetaActor( $actor, $name ) {
		return $this->checkActorOnDB(
			$this->getDB( DB_REPLICA, [], 'metawiki' ),
			$actor,
			$name
		);
	}

	/**
	 * Add the interwiki prefix to a name
	 *
	 * @param string $name
	 * @return string
	 */
	private function prefixName( $name ) {
		global $wgCentralAuthGlobalBlockInterwikiPrefix;
		if ( strpos( $name, '>' ) !== false ) {
			throw new \Exception( "Invalid name: $name" );
		}
		return ucfirst( $wgCentralAuthGlobalBlockInterwikiPrefix ) . ">$name";
	}

	/**
	 * Check whether the actor ID matches the given name on an arbitrary database
	 *
	 * @param IDatabase $db
	 * @param int $actor
	 * @param string $name
	 * @return bool
	 */
	private function checkActorOnDB( $db, $actor, $name ) {
		$existingName = $db->newSelectQueryBuilder()
			->select( 'actor_name' )
			->from( 'actor' )
			->where( [ 'actor_id' => $actor ] )
			->caller( __METHOD__ )
			->fetchField();

		if ( $existingName === false ) {
			return false;
		}
		return $existingName === $name
			|| $existingName === $this->prefixName( $name );
	}

	/**
	 * Get the actor_id for a given name, creating it if it doesn't exist.
	 * Similar to ActorMigration::getInsertValues() but doesn't require a
	 * UserIdentity.
	 *
	 * @param string $name
	 * @return int|bool
	 * @throws \Exception
	 */
	private function getActorId( $name ) {
		$dbr = $this->getDB( DB_REPLICA );
		$actor = $dbr->newSelectQueryBuilder()
			->select( 'actor_id' )
			->from( 'actor' )
			->where( [ 'actor_name' => $name ] )
			->caller( __METHOD__ )
			->fetchField();

		if ( $actor !== false ) {
			return $actor;
		}

		$dbw = $this->getDB( DB_MASTER );
		$dbw->insert(
			'actor',
			[
				'actor_user' => null,
				'actor_name' => $name
			],
			__METHOD__ );

		if ( $dbw->affectedRows() ) {
			return $dbw->insertId();
		}

		$actor = $dbw->newSelectQueryBuilder()
			->select( 'actor_id' )
			->from( 'actor' )
			->where( [ 'actor_name' => $name ] )
			->caller( __METHOD__ )
			->fetchField();

		if ( $actor !== false ) {
			return $actor;
		}

		throw new \Exception( "Unable to create actor for \"$name\"" );
	}

	/**
	 * Update an ipblocks row (if dry-run is false)
	 *
	 * @param int $blockId The ipb_id value
	 * @param string $adminName The name of the blocking admin (without interwiki prefix)
	 * @param int $oldActor The old ipb_by_actor
	 */
	private function updateActor( $blockId, $adminName, $oldActor ) {
		if ( $this->hasOption( 'dry-run' ) ) {
			$this->output( "DRY RUN: would change ipb_id $blockId to $adminName\n" );
			return;
		}

		$actor = $this->getActorId( $this->prefixName( $adminName ) );
		$this->output( "UPDATE: changing ipb_id {$blockId} from actor $oldActor to $actor $adminName\n" );
		$dbw = $this->getDB( DB_MASTER );
		$dbw->update(
			'ipblocks',
			[ 'ipb_by_actor' => $actor ],
			[ 'ipb_id' => $blockId ],
			__METHOD__
		);
	}
}

$maintClass = FixT260485::class;
require RUN_MAINTENANCE_IF_MAIN;
